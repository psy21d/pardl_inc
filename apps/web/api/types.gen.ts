// This file is auto-generated by @hey-api/openapi-ts

/**
 * Achievement data
 */
export type AchievementV1 = {
    id: string;
    name: string;
    description: string;
    iconLink: string;
};

/**
 * Page of achievements
 */
export type AchievementPageV1 = PageV1 & {
    content: Array<AchievementV1>;
};

/**
 * A summary of the AI analysis of the session
 */
export type AiSummaryV1 = {
    rating: number;
};

/**
 * Supported currencies for pricing
 */
export type CurrencyV1 = 'USD' | 'EUR' | 'GBP' | 'JPY' | 'AUD' | 'CAD' | 'CHF' | 'SEK' | 'DKK' | 'NOK' | 'NZD' | 'RUB' | 'SGD';

/**
 * Represents a document such as privacy policy or terms of service
 */
export type DocumentV1Readable = {
    /**
     * Unique identifier for the document
     */
    readonly id: string;
    /**
     * Title of the document
     */
    title: string;
    /**
     * Link to the document content
     */
    contentLink: string;
    /**
     * Version of the document
     */
    version: string;
    /**
     * Timestamp when the document was created
     */
    readonly createdAt: string;
    locale: LocaleV1;
};

/**
 * Represents a document such as privacy policy or terms of service
 */
export type DocumentV1Writable = {
    /**
     * Title of the document
     */
    title: string;
    /**
     * Link to the document content
     */
    contentLink: string;
    /**
     * Version of the document
     */
    version: string;
    locale: LocaleV1;
};

/**
 * Page of documents
 */
export type DocumentPageV1Readable = PageV1 & {
    content: Array<DocumentV1Readable>;
};

/**
 * Page of documents
 */
export type DocumentPageV1Writable = PageV1 & {
    content: Array<DocumentV1Writable>;
};

/**
 * Supported locales for documents
 */
export type LocaleV1 = 'en-US' | 'fr-FR' | 'es-ES' | 'de-DE' | 'da-DK' | 'it-IT' | 'ja-JP' | 'zh-CN' | 'ru-RU';

/**
 * Page metadata
 */
export type PageV1 = {
    number: number;
    size: number;
    totalPages: number;
    totalElements: number;
    first: boolean;
    last: boolean;
};

/**
 * Represents a subscription premium available in the app
 */
export type PremiumV1Readable = {
    /**
     * Unique identifier for the premium
     */
    readonly id: string;
    /**
     * Name of the premium subscription
     */
    name: string;
    /**
     * Detailed description of the premium subscription
     */
    description: string;
    /**
     * Type of the premium (e.g., monthly, yearly)
     */
    type: 'monthly' | 'yearly';
    /**
     * List of prices for the premium subscription in different currencies
     */
    prices: Array<{
        currency: CurrencyV1;
        /**
         * Price amount in the specified currency
         */
        quantity: number;
    }>;
    /**
     * Timestamp when the premium was created
     */
    readonly createdAt?: string;
};

/**
 * Represents a subscription premium available in the app
 */
export type PremiumV1Writable = {
    /**
     * Name of the premium subscription
     */
    name: string;
    /**
     * Detailed description of the premium subscription
     */
    description: string;
    /**
     * Type of the premium (e.g., monthly, yearly)
     */
    type: 'monthly' | 'yearly';
    /**
     * List of prices for the premium subscription in different currencies
     */
    prices: Array<{
        currency: CurrencyV1;
        /**
         * Price amount in the specified currency
         */
        quantity: number;
    }>;
};

/**
 * Page of premium subscriptions
 */
export type PremiumPageV1Readable = PageV1 & {
    content: Array<PremiumV1Readable>;
};

/**
 * Page of premium subscriptions
 */
export type PremiumPageV1Writable = PageV1 & {
    content: Array<PremiumV1Writable>;
};

/**
 * A Problem Details object (RFC 9457)
 */
export type ProblemDetailV1 = {
    /**
     * A short, human-readable summary of the problem type.
     * It SHOULD NOT change from occurrence to occurrence of the problem
     *
     */
    title: string;
    /**
     * The HTTP status code generated by the origin server for this occurrence of the problem.
     */
    status: number;
    /**
     * A human-readable explanation specific to this occurrence of the problem.
     */
    detail: string;
    /**
     * A URI reference that identifies the specific occurrence of the problem.
     */
    instance: string;
    /**
     * Trace ID generated by the service in OpenTelemetry format
     */
    traceId: string;
    /**
     * A URI reference RFC3986 that identifies the problem type. This specification encourages that,
     * when dereferenced, it provide human-readable documentation for the problem type
     * (e.g., using HTML [W3C.REC-html5-20141028]). When type cannot be presented as URI, its value should
     * be "about:blank".
     *
     */
    type: string;
    /**
     * Additional unstructured data that can be filled in by the service
     */
    additionalProperties?: {
        [key: string]: unknown;
    };
};

/**
 * Generic reward data
 */
export type RewardV1Readable = {
    /**
     * Unique identifier for the reward
     */
    readonly id: string;
    type: RewardTypeV1;
    /**
     * Name of the reward
     */
    name: string;
    /**
     * Detailed description of the reward
     */
    description?: string;
    /**
     * Value or amount associated with the reward
     */
    value: number;
    /**
     * Link to the reward's icon
     */
    icon_link?: string;
};

/**
 * Generic reward data
 */
export type RewardV1Writable = {
    type: RewardTypeV1;
    /**
     * Name of the reward
     */
    name: string;
    /**
     * Detailed description of the reward
     */
    description?: string;
    /**
     * Value or amount associated with the reward
     */
    value: number;
    /**
     * Link to the reward's icon
     */
    icon_link?: string;
};

/**
 * Types of rewards available in the app
 */
export type RewardTypeV1 = 'coins';

/**
 * Detailed data of a breathing session
 */
export type SessionDataV1 = {
    inhalesCount: number;
    exhalesCount: number;
    holdCount: number;
    inhalesTotalSeconds: number;
    exhalesTotalSeconds: number;
    holdTotalSeconds: number;
    maxInhaleLengthSeconds: number;
    maxExhaleLengthSeconds: number;
    maxHoldLengthSeconds: number;
};

/**
 * Page of breathing sessions
 */
export type SessionPageV1Readable = PageV1 & {
    content: Array<SessionV1Readable>;
};

/**
 * Page of breathing sessions
 */
export type SessionPageV1Writable = PageV1 & {
    content: Array<SessionV1Writable>;
};

/**
 * Breathing session result
 */
export type SessionV1Readable = {
    protocolName: string;
    durationSeconds: number;
    timestamp: string;
    aiSummary: AiSummaryV1;
    data: SessionDataV1;
    rewards?: Array<RewardV1Readable>;
    /**
     * Link to the bucket with raw session data
     */
    dataStreamLink: string;
};

/**
 * Breathing session result
 */
export type SessionV1Writable = {
    protocolName: string;
    durationSeconds: number;
    timestamp: string;
    aiSummary: AiSummaryV1;
    data: SessionDataV1;
    rewards?: Array<RewardV1Writable>;
    /**
     * Link to the bucket with raw session data
     */
    dataStreamLink: string;
};

/**
 * Tracks which achievements a user has unlocked and when
 */
export type UserAchievementV1Readable = {
    /**
     * Unique identifier of the user
     */
    readonly userId: string;
    /**
     * Unique identifier of the achievement
     */
    achievementId: string;
    /**
     * Timestamp when the user unlocked the achievement
     */
    unlockedAt: string;
};

/**
 * Tracks which achievements a user has unlocked and when
 */
export type UserAchievementV1Writable = {
    /**
     * Unique identifier of the achievement
     */
    achievementId: string;
    /**
     * Timestamp when the user unlocked the achievement
     */
    unlockedAt: string;
};

/**
 * Page of user achievements
 */
export type UserAchievementPageV1Readable = PageV1 & {
    content: Array<UserAchievementV1Readable>;
};

/**
 * Page of user achievements
 */
export type UserAchievementPageV1Writable = PageV1 & {
    content: Array<UserAchievementV1Writable>;
};

/**
 * Best results of the user
 */
export type UserBestResultsV1 = {
    userId: string;
    maxExhaleLengthSeconds: number;
    maxHoldLengthSeconds: number;
    maxStreakDays: number;
    currentStreakDays: number;
};

/**
 * Tracks the premium subscription a user has purchased and its details
 */
export type UserPremiumV1 = {
    /**
     * Unique identifier of the user
     */
    userId: string;
    /**
     * Unique identifier of the premium subscription
     */
    premiumId: string;
    /**
     * Timestamp when the premium subscription was activated
     */
    activatedAt: string;
    /**
     * Timestamp when the premium subscription expires
     */
    expiresAt?: string;
    /**
     * Status of the premium subscription (e.g., active, expired, canceled)
     */
    status: 'active' | 'expired' | 'canceled';
    /**
     * Payment method used for the subscription (e.g., credit card, PayPal)
     */
    paymentMethod?: string;
    /**
     * Unique identifier of the transaction for the purchase
     */
    transactionId?: string;
    /**
     * Indicates if the subscription is set to auto-renew
     */
    autoRenew?: boolean;
};

/**
 * Page of user premium subscriptions
 */
export type UserPremiumPageV1 = PageV1 & {
    content: Array<UserPremiumV1>;
};

/**
 * User profile data
 */
export type UserProfileV1 = {
    userId: string;
    username: string;
    email?: string;
};

/**
 * Tracks which version of a document a user has signed and when
 */
export type UserSignedDocumentV1 = {
    /**
     * Unique identifier of the user
     */
    userId: string;
    /**
     * Unique identifier of the document
     */
    documentId: string;
    /**
     * Version of the document the user signed
     */
    signedVersion: string;
    /**
     * Timestamp when the user signed the document
     */
    signedAt: string;
};

/**
 * Page of signed documents
 */
export type UserSignedDocumentPageV1 = PageV1 & {
    content: Array<UserSignedDocumentV1>;
};

/**
 * Unique identifier of the user
 */
export type UserId = string;

export type GetHealthV1Data = {
    body?: never;
    path?: never;
    query?: never;
    url: '/health/v1';
};

export type GetHealthV1Errors = {
    /**
     * The API is unavailable
     */
    503: {
        [key: string]: unknown;
    };
};

export type GetHealthV1Error = GetHealthV1Errors[keyof GetHealthV1Errors];

export type GetHealthV1Responses = {
    /**
     * The API is healthy
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetHealthV1Response = GetHealthV1Responses[keyof GetHealthV1Responses];

export type GetAchievementsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/metadata/v1/achievements';
};

export type GetAchievementsErrors = {
    /**
     * Unauthorized
     */
    401: ProblemDetailV1;
    /**
     * Forbidden
     */
    403: ProblemDetailV1;
};

export type GetAchievementsError = GetAchievementsErrors[keyof GetAchievementsErrors];

export type GetAchievementsResponses = {
    /**
     * List of achievements
     */
    200: AchievementPageV1;
};

export type GetAchievementsResponse = GetAchievementsResponses[keyof GetAchievementsResponses];

export type GetDocumentsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/metadata/v1/documents';
};

export type GetDocumentsErrors = {
    /**
     * Unauthorized
     */
    401: ProblemDetailV1;
    /**
     * Forbidden
     */
    403: ProblemDetailV1;
};

export type GetDocumentsError = GetDocumentsErrors[keyof GetDocumentsErrors];

export type GetDocumentsResponses = {
    /**
     * List of documents
     */
    200: Array<DocumentPageV1Readable>;
};

export type GetDocumentsResponse = GetDocumentsResponses[keyof GetDocumentsResponses];

export type GetPremiumsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/metadata/v1/premiums';
};

export type GetPremiumsErrors = {
    /**
     * Unauthorized
     */
    401: ProblemDetailV1;
    /**
     * Forbidden
     */
    403: ProblemDetailV1;
};

export type GetPremiumsError = GetPremiumsErrors[keyof GetPremiumsErrors];

export type GetPremiumsResponses = {
    /**
     * List of premiums
     */
    200: PremiumPageV1Readable;
};

export type GetPremiumsResponse = GetPremiumsResponses[keyof GetPremiumsResponses];

export type GetUserAchievementsData = {
    body?: never;
    path: {
        /**
         * Unique identifier of the user
         */
        userId: string;
    };
    query?: never;
    url: '/users/v1/{userId}/achievements';
};

export type GetUserAchievementsErrors = {
    /**
     * Unauthorized
     */
    401: ProblemDetailV1;
    /**
     * Forbidden
     */
    403: ProblemDetailV1;
};

export type GetUserAchievementsError = GetUserAchievementsErrors[keyof GetUserAchievementsErrors];

export type GetUserAchievementsResponses = {
    /**
     * List of user achievements
     */
    200: UserAchievementPageV1Readable;
};

export type GetUserAchievementsResponse = GetUserAchievementsResponses[keyof GetUserAchievementsResponses];

export type GetUserBestResultsData = {
    body?: never;
    path: {
        /**
         * Unique identifier of the user
         */
        userId: string;
    };
    query?: never;
    url: '/users/v1/{userId}/best-results';
};

export type GetUserBestResultsErrors = {
    /**
     * Unauthorized
     */
    401: ProblemDetailV1;
    /**
     * Forbidden
     */
    403: ProblemDetailV1;
};

export type GetUserBestResultsError = GetUserBestResultsErrors[keyof GetUserBestResultsErrors];

export type GetUserBestResultsResponses = {
    /**
     * User best results
     */
    200: UserBestResultsV1;
};

export type GetUserBestResultsResponse = GetUserBestResultsResponses[keyof GetUserBestResultsResponses];

export type GetUserPremiumsData = {
    body?: never;
    path: {
        /**
         * Unique identifier of the user
         */
        userId: string;
    };
    query?: never;
    url: '/users/v1/{userId}/premiums';
};

export type GetUserPremiumsErrors = {
    /**
     * Unauthorized
     */
    401: ProblemDetailV1;
    /**
     * Forbidden
     */
    403: ProblemDetailV1;
};

export type GetUserPremiumsError = GetUserPremiumsErrors[keyof GetUserPremiumsErrors];

export type GetUserPremiumsResponses = {
    /**
     * List of user-specific premiums
     */
    200: UserPremiumPageV1;
};

export type GetUserPremiumsResponse = GetUserPremiumsResponses[keyof GetUserPremiumsResponses];

export type GetUserProfileData = {
    body?: never;
    path: {
        /**
         * Unique identifier of the user
         */
        userId: string;
    };
    query?: never;
    url: '/users/v1/{userId}/profile';
};

export type GetUserProfileErrors = {
    /**
     * Unauthorized
     */
    401: ProblemDetailV1;
    /**
     * Forbidden
     */
    403: ProblemDetailV1;
    /**
     * Not found
     */
    404: ProblemDetailV1;
};

export type GetUserProfileError = GetUserProfileErrors[keyof GetUserProfileErrors];

export type GetUserProfileResponses = {
    /**
     * Full profile data
     */
    200: UserProfileV1;
};

export type GetUserProfileResponse = GetUserProfileResponses[keyof GetUserProfileResponses];

export type PatchUserProfileData = {
    body: {
        name?: string;
    };
    path: {
        /**
         * Unique identifier of the user
         */
        userId: string;
    };
    query?: never;
    url: '/users/v1/{userId}/profile';
};

export type PatchUserProfileErrors = {
    /**
     * Bad request
     */
    400: ProblemDetailV1;
    /**
     * Unauthorized
     */
    401: ProblemDetailV1;
    /**
     * Forbidden
     */
    403: ProblemDetailV1;
    /**
     * Unprocessable Entity
     */
    422: ProblemDetailV1;
};

export type PatchUserProfileError = PatchUserProfileErrors[keyof PatchUserProfileErrors];

export type PatchUserProfileResponses = {
    /**
     * Updated user profile
     */
    200: UserProfileV1;
};

export type PatchUserProfileResponse = PatchUserProfileResponses[keyof PatchUserProfileResponses];

export type GetSessionsData = {
    body?: never;
    path: {
        /**
         * Unique identifier of the user
         */
        userId: string;
    };
    query?: never;
    url: '/users/v1/{userId}/sessions';
};

export type GetSessionsErrors = {
    /**
     * Unauthorized
     */
    401: ProblemDetailV1;
    /**
     * Forbidden
     */
    403: ProblemDetailV1;
};

export type GetSessionsError = GetSessionsErrors[keyof GetSessionsErrors];

export type GetSessionsResponses = {
    /**
     * List of breathing sessions
     */
    200: SessionPageV1Readable;
};

export type GetSessionsResponse = GetSessionsResponses[keyof GetSessionsResponses];

export type PostSessionData = {
    body: SessionV1Writable;
    path: {
        /**
         * Unique identifier of the user
         */
        userId: string;
    };
    query?: never;
    url: '/users/v1/{userId}/sessions';
};

export type PostSessionErrors = {
    /**
     * Bad request
     */
    400: ProblemDetailV1;
    /**
     * Unauthorized
     */
    401: ProblemDetailV1;
    /**
     * Forbidden
     */
    403: ProblemDetailV1;
    /**
     * Unprocessable Entity
     */
    422: ProblemDetailV1;
};

export type PostSessionError = PostSessionErrors[keyof PostSessionErrors];

export type PostSessionResponses = {
    /**
     * Session result uploaded
     */
    201: unknown;
};

export type GetSignedDocumentsData = {
    body?: never;
    path: {
        /**
         * Unique identifier of the user
         */
        userId: string;
    };
    query?: never;
    url: '/users/v1/{userId}/signed-documents';
};

export type GetSignedDocumentsErrors = {
    /**
     * Unauthorized
     */
    401: ProblemDetailV1;
    /**
     * Forbidden
     */
    403: ProblemDetailV1;
};

export type GetSignedDocumentsError = GetSignedDocumentsErrors[keyof GetSignedDocumentsErrors];

export type GetSignedDocumentsResponses = {
    /**
     * List of signed documents
     */
    200: UserSignedDocumentPageV1;
};

export type GetSignedDocumentsResponse = GetSignedDocumentsResponses[keyof GetSignedDocumentsResponses];

export type ClientOptions = {
    baseUrl: `${string}://{host}` | (string & {});
};